steps:
  - id: 'check-cluster'
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        if gcloud container clusters describe ${_CLUSTER_NAME} \
          --project=${PROJECT_ID} \
          --region=${_REGION} --format="none" 2>/dev/null; then
          echo "Cluster exists, skipping creation"
          exit 0
        else
          echo "Cluster not found, will create"
          gcloud container clusters create-auto ${_CLUSTER_NAME} \
            --project=${PROJECT_ID} \
            --region=${_REGION} \
            --quiet
        fi

  - id: 'setup-artifact-registry'
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    waitFor: ['check-cluster']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        if gcloud artifacts repositories describe ${_ARTIFACT_REGISTRY_ID} \
          --project=${PROJECT_ID} \
          --location=${_REGION} --format="none" 2>/dev/null; then
          echo "Repository exists, skipping creation"
        else
          echo "Creating Artifact Registry repository"
          gcloud artifacts repositories create ${_ARTIFACT_REGISTRY_ID} \
            --repository-format=docker \
            --location=${_REGION} \
            --quiet
        fi

  - id: 'build-push-image'
    name: 'gcr.io/cloud-builders/docker'
    waitFor: ['setup-artifact-registry']
    args:
      - 'build'
      - '-t'
      - '${_REGION}-docker.pkg.dev/${PROJECT_ID}/${_ARTIFACT_REGISTRY_ID}/${_IMAGE_NAME}:${_IMAGE_TAG}'
      - '.'

  - id: 'setup-k8s-iam'
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    waitFor: ['build-push-image']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        # Get cluster credentials
        gcloud container clusters get-credentials ${_CLUSTER_NAME} \
          --project=${PROJECT_ID} \
          --region=${_REGION}

        # Check and create namespace
        if ! kubectl get namespace ${_NAMESPACE} 2>/dev/null; then
          kubectl create namespace ${_NAMESPACE}
        fi

        # Check and create KSA
        if ! kubectl get serviceaccount ${_KSA_NAME} -n ${_NAMESPACE} 2>/dev/null; then
          kubectl create serviceaccount ${_KSA_NAME} -n ${_NAMESPACE}
        fi

        # Check and create IAM SA
        if ! gcloud iam service-accounts describe ${_IAM_SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com \
          --project=${PROJECT_ID} 2>/dev/null; then
          gcloud iam service-accounts create ${_IAM_SA_NAME} \
            --project=${PROJECT_ID} \
            --display-name="${_IAM_SA_DISPLAY_NAME}"
        fi

        # Add IAM roles (idempotent)
        gcloud projects add-iam-policy-binding ${PROJECT_ID} \
          --member="serviceAccount:${_IAM_SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com" \
          --role="roles/aiplatform.admin" \
          --quiet

        # Setup workload identity (idempotent)
        gcloud iam service-accounts add-iam-policy-binding \
          ${_IAM_SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com \
          --role roles/iam.workloadIdentityUser \
          --member "serviceAccount:${PROJECT_ID}.svc.id.goog[${_NAMESPACE}/${_KSA_NAME}]" \
          --quiet

        kubectl annotate serviceaccount ${_KSA_NAME} \
          --namespace ${_NAMESPACE} \
          iam.gke.io/gcp-service-account=${_IAM_SA_NAME}@${PROJECT_ID}.iam.gserviceaccount.com \
          --overwrite

  - id: 'deploy-app'
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    waitFor: ['setup-k8s-iam']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        gcloud container clusters get-credentials ${_CLUSTER_NAME} \
          --project=${PROJECT_ID} \
          --region=${_REGION}
        
        # Replace variables in deployment.yaml and apply
        cat deployment.yaml | \
        sed "s|\${_REGION}|${_REGION}|g; \
            s|\${PROJECT_ID}|${PROJECT_ID}|g; \
            s|\${_ARTIFACT_REGISTRY_ID}|${_ARTIFACT_REGISTRY_ID}|g; \
            s|\${_IMAGE_NAME}|${_IMAGE_NAME}|g; \
            s|\${_IMAGE_TAG}|${_IMAGE_TAG}|g; \
            s|\${_NAMESPACE}|${_NAMESPACE}|g; \
            s|\${_KSA_NAME}|${_KSA_NAME}|g; \
            s|\${_IAM_SA_NAME}|${_IAM_SA_NAME}|g" | \
        kubectl apply -f -

  - id: 'get-service-ip'
    name: 'gcr.io/google.com/cloudsdktool/cloud-sdk'
    waitFor: ['deploy-app']
    entrypoint: 'bash'
    args:
      - '-c'
      - |
        echo "Waiting for LoadBalancer IP assignment..."
        
        # Function to get External IP
        get_external_ip() {
          kubectl get service -n ${_NAMESPACE} \
            --selector=app=${_IMAGE_NAME} \
            -o jsonpath='{.items[0].status.loadBalancer.ingress[0].ip}'
        }
        
        # Wait for IP with timeout
        TIMEOUT=300  # 5 minutes timeout
        INTERVAL=10  # Check every 10 seconds
        ELAPSED=0
        
        until [ -n "$$(get_external_ip)" ] || [ $$ELAPSED -ge $$TIMEOUT ]; do
          echo "Waiting for external IP... ($$ELAPSED seconds elapsed)"
          sleep $$INTERVAL
          ELAPSED=$$((ELAPSED + INTERVAL))
        done
        
        EXTERNAL_IP=$$(get_external_ip)
        
        if [ -n "$$EXTERNAL_IP" ]; then
          echo "‚úÖ Service is ready!"
          echo "###################################################"
          echo "# Deployment complete! üöÄ                          #"
          echo "# External IP: $$EXTERNAL_IP                       #"
          echo "# Services available at:                           #"
          echo "# Streamlit UI: http://$$EXTERNAL_IP:8501         #"
          echo "# VNC: $$EXTERNAL_IP:5900                         #"
          echo "# noVNC Web UI: http://$$EXTERNAL_IP:6080        #"
          echo "# Web: http://$$EXTERNAL_IP:8080                  #"
          echo "###################################################"
        else
          echo "‚ùå Timeout waiting for external IP"
          echo "Please check the service status manually:"
          echo "kubectl get service -n ${_NAMESPACE} --selector=app=${_IMAGE_NAME}"
          exit 1
        fi


timeout: '3600s'
options:
  logging: CLOUD_LOGGING_ONLY
  machineType: 'E2_HIGHCPU_8'
  dynamicSubstitutions: true
substitutions:
  _REGION: us-east5
  _CLUSTER_NAME: computer-use-demo-cluster
  _ARTIFACT_REGISTRY_ID: computer-use-ar-repo
  _NAMESPACE: computer-use-demo
  _KSA_NAME: computer-use-ksa
  _IAM_SA_NAME: computer-use-sa
  _IAM_SA_DISPLAY_NAME: Computer Use Demo SA
  _IMAGE_NAME: computer-use-demo
  _IMAGE_TAG: latest
tags: ['gke-deployment', '${_CLUSTER_NAME}']